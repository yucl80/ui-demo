<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>mxGraph with Cubic Bezier Curve</title>
    <script src="https://cdn.jsdelivr.net/npm/mxgraph@4.2.2/javascript/mxClient.js"></script>
    <style>
        #graphContainer {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            background: #f0f0f0;
        }
    </style>
</head>

<body>
    <div id="graphContainer"></div>
    <script>
        // 二次贝塞尔曲线（Quadratic Bezier Curve）：这种曲线有两个端点和一个控制点。在SVG中，你可以通过<path>元素的Q或q命令来创建二次贝塞尔曲线。Q命令后跟控制点的x和y坐标，然后是终点的x和y坐标。大写字母表示绝对坐标，小写字母表示相对坐标。例子：
        // <path d="M10 10 Q 50 100 100 10" stroke="black" fill="transparent"/>
        // 三次贝塞尔曲线（Cubic Bezier Curve）：这种曲线有两个端点和两个控制点。在SVG中，你可以通过<path>元素的C或c命令来创建三次贝塞尔曲线。C命令后跟第一个控制点的x和y坐标，第二个控制点的x和y坐标，然后是终点的x和y坐标。例子：
        // <path d="M10 10 C 50 100 150 100 100 10" stroke="black" fill="transparent"/>
        // Check if the browser supports HTML5 Canvas
        if (!mxClient.isBrowserSupported()) {
            mxUtils.error('Browser is not supported!', 200, false);
        } else {
            function toJsonStr(json_data) {
                var cache = [];
                var json_str = JSON.stringify(json_data, function (key, value) {
                    if (typeof value === 'object' && value !== null) {
                        if (cache.indexOf(value) !== -1) {
                            return;
                        }
                        cache.push(value);
                    }
                    return value;
                });
                cache = null;
                return json_str;
            }
            function calculateControlPoints(points) {
                var controlPoints = [];
                for (var i = 0; i < points.length - 1; i++) {
                    var p1 = points[i];
                    var p2 = points[i + 1];
                    var midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 }; // 中点
                    var dx = p2.x - p1.x;
                    var dy = p2.y - p1.y;
                    var angle = Math.atan2(dy, dx); // 计算角度
                    var offset = Math.min(Math.abs(dx), Math.abs(dy)) * 0.7; // 控制点偏移量，基于边段长度

                    // 计算控制点，考虑转角大小的平滑度调整
                    var cp1 = {
                        x: midPoint.x - offset * Math.cos(angle - Math.PI / 2),
                        y: midPoint.y - offset * Math.sin(angle - Math.PI / 2)
                    };
                    var cp2 = {
                        x: midPoint.x + offset * Math.cos(angle + Math.PI / 2),
                        y: midPoint.y + offset * Math.sin(angle + Math.PI / 2)
                    };

                    controlPoints.push(cp1, cp2); // 保存控制点对
                }

                return controlPoints;
            }

            // 自定义二次贝塞尔曲线边缘形状
            function CustomQuadraticBezierEdgeShape() {
                mxEdgeShape.call(this);
            }

            // 继承 mxEdgeShape
            mxUtils.extend(CustomQuadraticBezierEdgeShape, mxEdgeShape);

            // 重写父类的 redrawPath 方法
            CustomQuadraticBezierEdgeShape.prototype.redrawPath = function (path, terminalState, terminalState2, constraint) {
                // 获取起点和终点的位置
                var pt = this.getTerminalPoint(terminalState);
                var pt2 = this.getTerminalPoint(terminalState2);

                // 获取控制点，这里我们简单地将控制点设置为起点和终点的中点
                // 在实际应用中，你可能需要根据具体情况计算控制点
                var controlX = (pt.x + pt2.x) / 2;
                var controlY = (pt.y + pt2.y) / 2;

                // 使用二次贝塞尔曲线绘制路径
                path.moveTo(pt.x, pt.y);
                path.quadTo(controlX, controlY, pt2.x, pt2.y);
            };

            // 注册自定义边缘形状
            mxShapeRegistry.registerShape('customQuadraticBezierEdge', CustomQuadraticBezierEdgeShape);

            // 现在，你可以在创建边缘时使用 customQuadraticBezierEdge 作为形状
            var edge = new mxCell('', new mxGeometry(0, 0, 0, 0), 'customQuadraticBezierEdge');
            edge.geometry.setTerminalPoint(new mxPoint(100, 100), true);
            edge.geometry.setTerminalPoint(new mxPoint(200, 200), false);

            // 将边缘添加到图形中
            var graph = new mxGraph(container);
            graph.addEdge(edge);

            // Create the graph inside the container
            var container = document.getElementById('graphContainer');
            var graph = new mxGraph(container);

            // Define a custom style for the cubic bezier curve
            var style = graph.getStylesheet().getDefaultEdgeStyle();

            style[mxConstants.STYLE_EDGE] = mxEdgeStyle.ElbowConnector;
            // style[mxConstants.STYLE_EDGE] = mxEdgeStyle.OrthConnector
            style[mxConstants.STYLE_CURVED] = 1;
            // Insert a custom cubic bezier curve
            var parent = graph.getDefaultParent();
            graph.getModel().beginUpdate();
            try {
                var v1 = graph.insertVertex(parent, null, 'v1', 100, 200, 80, 30);
                var v2 = graph.insertVertex(parent, null, 'v2', 400, 400, 80, 30);
                var v3 = graph.insertVertex(parent, null, 'v3', 100, 400, 80, 30);
                var v4 = graph.insertVertex(parent, null, 'v4', 400, 100, 80, 30);
                var edge3 = graph.insertEdge(parent, null, '', v1, v4);
                var edge1 = graph.insertEdge(parent, null, 'edge1', v2, v1);
            } finally {
                graph.getModel().endUpdate();
            }

            // Custom cubic bezier edge style
            mxEdgeStyle.cubicBezierEdgeStyle = function (state, source, target, points, result) {
                console.log("call mxEdgeStyle");
                data = [];
                mxEdgeStyle.ElbowConnector(state, source, target, points, data);
                rst = result;
                var controlPoints = calculateControlPoints(data);

                console.log(result);
                console.log(data);
                result[1] = controlPoints[0];
                result[2] = controlPoints[1];

                var pt1 = result[0];
                var pt2 = result[result.length - 1];

                // console.log(pt1.x + "," + pt1.y + " -> " + pt2.x + "," + pt2.y);
                // pt1.x = pt1.x + source.width;
                // pt1.y = pt1.y + source.height / 2;

                // pt2.x = pt2.x;
                // pt2.y = pt2.y + target.height / 2;

                // // console.log("points:"+toJsonStr(points));
                // // console.log("source:"+toJsonStr(source) + " ->  target:" + toJsonStr(target));
                // console.log(pt1.x + "," + pt1.y + " -> " + pt2.x + "," + pt2.y);
                // // console.log(points);
                // var control1 = new mxPoint((2 * pt1.x + pt2.x) / 3, pt1.y);
                // var control2 = new mxPoint((pt1.x + 2 * pt2.x) / 3, pt2.y);
                // result.length = 0;

                // result.push(new mxPoint(pt1.x, pt1.y));
                // result.push(control1);
                // result.push(control2);
                // result.push(new mxPoint(pt2.x, pt2.y));

                // console.log(x1 + "," + y1 + ":" + x2 + "," + y2);
                // // 获取边的起点和终点的坐标
                // console.log(state.absolutePoints[0]);

                // var sourcePoint = state.absolutePoints[0] ? graph.getConnectionPoint(source, state.absolutePoints[0]) : null;
                // var targetPoint = state.absolutePoints[state.absolutePoints.length - 1] ? graph.getConnectionPoint(target, state.absolutePoints[state.absolutePoints.length - 1]) : null;

                // if (sourcePoint && targetPoint) {
                //     // 打印坐标到控制台
                //     console.log('Source:', sourcePoint.x, sourcePoint.y);
                //     console.log('Target:', targetPoint.x, targetPoint.y);
                // } else {
                //     console.error('无法获取连接点坐标');
                // }

            };


            // mxStyleRegistry.putValue('cubicBezierEdgeStyle', mxEdgeStyle.cubicBezierEdgeStyle);

            // var encoder = new mxCodec();
            // var node = encoder.encode(graph.getModel());
            // var xml = mxUtils.getXml(node);
            // console.log(xml);
            // // style[mxConstants.STYLE_EDGE] = mxEdgeStyle.cubicBezierEdgeStyle;
            // // style[mxConstants.STYLE_CURVED] = 1;
            // graph.getModel().beginUpdate();
            // try {
            //     //todo 修改所有边的样式为 cubicBezierEdgeStyle
            //     var edges = graph.getChildEdges(parent);
            //     for (var i = 0; i < edges.length; i++) {
            //         // graph.setCellStyle('edgeStyle=cubicBezierEdgeStyle;', [edges[i]]);
            //         // graph.setCellStyle(mxConstants.STYLE_EDGE,'cubicBezierEdgeStyle', [edges[i]]);
            //         console.log(graph.view.getState(edges[i]).style);
            //         console.log(edges[i]);
            //         var style = edges[i].getStyle();
            //         var styleObj = mxStyleRegistry.parseStyle(style);
            //         console.log(styleObj);
            //         graph.getModel().setStyle(edges[i], 'cubicBezierEdgeStyle');
            //     }
            // } finally {
            //     graph.getModel().endUpdate();
            // }

        }
    </script>
</body>

</html>